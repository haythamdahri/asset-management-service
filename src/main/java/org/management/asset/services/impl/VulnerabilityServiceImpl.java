package org.management.asset.services.impl;

import org.apache.commons.lang3.StringUtils;
import org.management.asset.bo.Typology;
import org.management.asset.bo.Vulnerability;
import org.management.asset.dao.TypologyRepository;
import org.management.asset.dto.PageDTO;
import org.management.asset.dto.VulnerabilityRequestDTO;
import org.management.asset.dto.VulnerabilityResponseDTO;
import org.management.asset.exceptions.BusinessException;
import org.management.asset.exceptions.TechnicalException;
import org.management.asset.helpers.PaginationHelper;
import org.management.asset.services.RiskAnalysisService;
import org.management.asset.services.TypologyService;
import org.management.asset.services.VulnerabilityService;
import org.management.asset.utils.Constants;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Sort;
import org.springframework.stereotype.Service;

import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.atomic.AtomicReference;
import java.util.stream.Collectors;

/**
 * @author Haytham DAHRI
 */
@Service
public class VulnerabilityServiceImpl implements VulnerabilityService {

    @Autowired
    private TypologyService typologyService;

    @Autowired
    private RiskAnalysisService riskAnalysisService;

    @Autowired
    private TypologyRepository typologyRepository;

    @Autowired
    private PaginationHelper paginationHelper;

    @Override
    public List<Vulnerability> getVulnerabilities() {
        return this.typologyService.getTypologies().stream().map(Typology::getVulnerabilities).flatMap(List::stream).collect(Collectors.toList());
    }

    @Override
    public Integer getVulnerabilitiesCounter() {
        return this.typologyRepository.findAll().stream().map(typology -> {
            if( typology.getVulnerabilities() != null ) {
                return typology.getVulnerabilities().size();
            }
            return 0;
        }).reduce(0, Integer::sum);
    }

    @Override
    public PageDTO<VulnerabilityResponseDTO> getVulnerabilities(String name, int page, int size, String direction, String... sort) {
        List<VulnerabilityResponseDTO> vulnerabilityResponses = new ArrayList<>();
        List<Typology> typologies;
        // Sort by typology depending on sort
        if (sort[0].equals("typology")) {
            // Reverse Asset
            if (direction.equals(Sort.Direction.ASC.name())) {
                typologies = this.typologyRepository.findAll(Sort.by("name").descending());
            } else {
                typologies = this.typologyRepository.findAll(Sort.by("name").ascending());
            }
        } else {
            typologies = this.typologyRepository.findAll();
        }
        typologies.forEach(typology -> {
            if (typology.getVulnerabilities() != null) {
                typology.getVulnerabilities().forEach(vulnerability -> {
                    if (vulnerability.getName().toLowerCase().contains(name.toLowerCase())) {
                        vulnerabilityResponses.add(new VulnerabilityResponseDTO(typology.getId(), typology.getName(), vulnerability));
                    }
                });
            }
        });
        // Sort ThreatResponses
        vulnerabilityResponses.sort((t1, t2) -> {
            switch (sort[0]) {
                case "name":
                    return t1.getVulnerability().getName().compareTo(t2.getVulnerability().getName());
                case "description":
                    return t1.getVulnerability().getDescription().compareTo(t2.getVulnerability().getDescription());
                case "status":
                    return t2.getVulnerability().getStatus().compareTo(t1.getVulnerability().getStatus());
                default:
                    return t1.getVulnerability().getIdentificationDate().compareTo(t2.getVulnerability().getIdentificationDate());
            }
        });
        // Reverse list if direction is DESC
        if (direction.equals(Sort.Direction.DESC.name())) {
            Collections.reverse(vulnerabilityResponses);
        }
        // Pagination
        return this.paginationHelper.buildPage(page, size, vulnerabilityResponses);
    }

    @Override
    public VulnerabilityResponseDTO saveVulnerability(VulnerabilityRequestDTO vulnerabilityRequest) {
        try {
            final boolean vulnerabilityRequestIdNotExists = StringUtils.isEmpty(vulnerabilityRequest.getVulnerability()) ||
                    vulnerabilityRequest.getVulnerability() == null ||
                    StringUtils.equals(vulnerabilityRequest.getVulnerability(), "null") ||
                    StringUtils.equals(vulnerabilityRequest.getVulnerability(), "undefined");
            vulnerabilityRequest.setVulnerability(vulnerabilityRequestIdNotExists ? null : vulnerabilityRequest.getVulnerability());
            AtomicReference<Vulnerability> vulnerabilityAtomicReference = new AtomicReference<>(null);
            // Get typology
            Typology typology = this.typologyRepository.findById(vulnerabilityRequest.getTypology()).orElseThrow(BusinessException::new);
            // Check if name is already used in same typology of threats
            if (typology.getVulnerabilities() != null && typology.getVulnerabilities().stream().anyMatch(vulnerability ->
                    vulnerability.getName().equalsIgnoreCase(vulnerabilityRequest.getName()) && !StringUtils.equals(vulnerability.getId(), vulnerabilityRequest.getVulnerability()))) {
                throw new BusinessException(Constants.VULNERABILITY_NAME_ALREADY_TAKEN);
            }
            // Check if new threat
            if (vulnerabilityRequestIdNotExists) {
                // Create new Threat and push it
                Vulnerability vulnerability = new Vulnerability();
                vulnerability.setName(vulnerabilityRequest.getName());
                vulnerability.setDescription(vulnerabilityRequest.getDescription());
                vulnerability.setStatus(vulnerabilityRequest.isStatus());
                vulnerability.setIdentificationDate(LocalDateTime.now());
                // Add threat to typology
                typology.addVulnerability(vulnerability);
                // Save typology
                this.typologyRepository.save(typology);
                return new VulnerabilityResponseDTO(typology.getId(), typology.getName(), vulnerability);
            }
            // Check if typology is not changed
            if (StringUtils.equals(vulnerabilityRequest.getTypology(), vulnerabilityRequest.getCurrentTypology())) {
                // Update Vulnerability status
                typology.setVulnerabilities(typology.getVulnerabilities().stream().peek(vulnerability -> {
                    if (StringUtils.equals(vulnerabilityRequest.getVulnerability(), vulnerability.getId())) {
                        vulnerability.setName(vulnerabilityRequest.getName());
                        vulnerability.setDescription(vulnerabilityRequest.getDescription());
                        vulnerability.setStatus(vulnerabilityRequest.isStatus());
                        vulnerabilityAtomicReference.set(vulnerability);
                    }
                }).collect(Collectors.toList()));
            } else {
                // Remove threat from old typology
                Typology currentTypology = this.typologyRepository.findById(vulnerabilityRequest.getCurrentTypology()).orElseThrow(BusinessException::new);
                currentTypology.setVulnerabilities(currentTypology.getVulnerabilities().stream().filter(vulnerability -> !StringUtils.equals(vulnerability.getId(), vulnerabilityRequest.getVulnerability())).collect(Collectors.toList()));
                this.typologyRepository.save(currentTypology);
                // Create new Vulnerability and push it
                Vulnerability vulnerability = new Vulnerability();
                vulnerability.setName(vulnerabilityRequest.getName());
                vulnerability.setDescription(vulnerabilityRequest.getDescription());
                vulnerability.setStatus(vulnerabilityRequest.isStatus());
                vulnerability.setIdentificationDate(LocalDateTime.now());
                // Add threat to typology
                typology.addVulnerability(vulnerability);
                this.typologyRepository.save(typology);
                return new VulnerabilityResponseDTO(typology.getId(), typology.getName(), vulnerability);
            }
            // Save typology if threat found
            if (vulnerabilityAtomicReference.get() != null) {
                this.typologyRepository.save(typology);
                // Update RiskAnalysis threat
                this.riskAnalysisService.updateRiskAnalysisVulnerability(typology.getId(), vulnerabilityAtomicReference.get());
                // Return response
                return new VulnerabilityResponseDTO(typology.getId(), typology.getName(), vulnerabilityAtomicReference.get());
            }
            throw new BusinessException(Constants.ERROR);
        } catch (BusinessException ex) {
            ex.printStackTrace();
            throw ex;
        } catch (Exception ex) {
            ex.printStackTrace();
            throw new TechnicalException(ex.getMessage());
        }
    }
}
